<?xml version="1.0" encoding="utf-8" ?>
<rss version="1.0">
    <channel>
        <title>Revolution blahg</title>
        <link>http://mapleoin.bluepink.ro/</link>
        <description>mapleoin's rambling blahg</description>
        <language>en</language>
        <pubDate>Mon, 16 Aug 2010 18:07:49 +0300</pubDate>
        <generator>pyBlee!</generator>
        <item>
            <title>Fedora Summer Coding midterm</title>
            <link>http://mapleoin.bluepink.ro/perma/midterm-report</link>
            <author>mapleoin@bluepink.ro (Oin Maple)</author>
            <description>  &lt;p&gt;This midterm scared me when I found out about it on Friday when I looked at the schedule I had set myself. However, I have done the work that I should have done by this point in the project. When I wrote the proposal I had assumed that the buildsystem would already be built before me starting coding on the TG app, but that is not the case. Therefore I could only code the user-facing &lt;span class="caps"&gt;JSON&lt;/span&gt; interface that interacts with the DB as it would if the buildsystem would provide it with packages and repos. Except that there are no packages and repos at this stage.&lt;/p&gt;
&lt;p&gt;So for this midterm, we&amp;#8217;ve got working Copr &lt;span class="caps"&gt;CRUD&lt;/span&gt;, dependency handling and release/repo editing on a Copr. I also coded the Package &lt;span class="caps"&gt;CRUD&lt;/span&gt;, which basically allows for uploads of SRPMs, stores the info in the db and also allows for information retrieval and deleting packages. Actually building packages and retrieving packagebuilds will have to wait for the buildsystem to be built.&lt;/p&gt;
&lt;p&gt;After I finish polishing things a bit, I will probably start working on a basic client and then maybe move on to working on the buildsystem part of Copr. That should be loads of fun especially since I haven&amp;#8217;t done anything quite like this before. So it will be hard, but fun :).&lt;/p&gt;
&lt;p&gt;If anyone wants to check out what Copr looks like so far, you&amp;#8217;ll just have to install TurboGears 2.0.x and then:&lt;/p&gt;
&lt;div class="Bash"&gt;&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="nv"&gt;$ &lt;/span&gt;bzr branch bzr://bzr.fedorahosted.org/bzr/copr/devel
 &lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;devel
 &lt;span class="nv"&gt;$ &lt;/span&gt;python setup.py develop
 &lt;span class="nv"&gt;$ &lt;/span&gt;paster setup-app development.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;And you should have a working Copr. You can run the unit tests with the &lt;code&gt;nosetests&lt;/code&gt; command and all 52 of them should run fine. Yay!&lt;/p&gt;
&lt;p&gt;Congratulations to everyone who is finishing their &lt;span class="caps"&gt;FSC&lt;/span&gt; adventure today! I&amp;#8217;ll still be coding for another month or so.&lt;/p&gt; </description>
            <pubDate>Mon, 16 Aug 2010 12:17 GMT</pubDate>
        </item>
        <item>
            <title>Copr design - being all things to all people</title>
            <link>http://mapleoin.bluepink.ro/perma/copr-design-being-all-things</link>
            <author>mapleoin@bluepink.ro (Oin Maple)</author>
            <description>  &lt;p&gt;Lots of things happened this third Fedora Summer Coding week. Most people are already wrapping up, but I feel like I&amp;#8217;m still at the beginning.&lt;/p&gt;
&lt;p&gt;The biggest accomplishment of this week has got to be the fact that we (I and my mentor, Toshio) settled on a stable design for representing Coprs, Repos and their relationships. It was harder than it might seem, since we&amp;#8217;ve got all these different entities in Fedora: we&amp;#8217;ve got repos that you could look at as being either a directory with a release and an architecture or a repofile that is the same across releases and arches. When talking about releases we&amp;#8217;ve got Fedora releases (e.g. Fedora 13, Fedora 14) and then we&amp;#8217;ve got the packages for other distros with their own releases: &lt;span class="caps"&gt;EPEL&lt;/span&gt; and &lt;span class="caps"&gt;OLPC&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now, on top of all of this we&amp;#8217;ve got Coprs and (at least) two groups of users for the API: the end-users of the Coprs &amp;#8211; the people that install the repos and the packages and the developers of the packages in the Coprs. The end users shouldn&amp;#8217;t have to deal with the intricacies of the Copr/Repos/Releases model; ideally they&amp;#8217;d just have one big button per the distribution they&amp;#8217;re using, so they can install the repo once and have it work even after they&amp;#8217;ve upgraded their distro three times or reinstalled five times (which is sort of how a repofile works). The package developers on the other hand could get hurt by the differences between different distro releases and their different packages &amp;#8211; when depending on different package versions for example.&lt;/p&gt;
&lt;p&gt;So finally we get to Coprs which should basically be a collection of packages that are available for one or more distros with each one having one or more releases. The package maintainer gets to create a Copr and choose a number of releases which they want to support with that Copr. One Copr can depend on as many other Coprs as needed. When the maintainer creates a Copr, the Copr App will automatically create repos for all of the specified releases and for each of the architectures that are supported by the buildsystem.&lt;/p&gt;
&lt;p&gt;Everything I said until now is already implemented at the level of the TurboGears App which will provide the &lt;span class="caps"&gt;API&lt;/span&gt; for the web interface and any number of &lt;span class="caps"&gt;JSON&lt;/span&gt; clients. The schema is built and the database insteraction works fine, but repos don&amp;#8217;t actually get created, because that&amp;#8217;s not part of my proposal and will be handled at a different level. Oh and it&amp;#8217;s all unit tested!&lt;/p&gt;
&lt;p&gt;This week wasn&amp;#8217;t just designing and building though, I spent a lot of time digging through TurboGears2 and its sub-packages&amp;#8217; documentation for things that should make the code simpler: raising &lt;span class="caps"&gt;JSON&lt;/span&gt; errors from nested functions, sending list arguments to &lt;span class="caps"&gt;JSON&lt;/span&gt; functions via WebTest post requests and even returning a flat list from a SQLAlchemy query on a single table column. All of these things seem to me like they should already be implemented and easy to use which makes me waste time searching for them. In fact they either are bugs or require coding them myself (at least from what I understand so far). I&amp;#8217;ll have to investigate further, especially now since the weekend is over and I hope there&amp;#8217;ll be more people answering questions on &lt;span class="caps"&gt;IRC&lt;/span&gt; and on issue trackers.&lt;/p&gt;
&lt;p&gt;This next week I&amp;#8217;ll mostly start worrying about what happens when a package maintainer submits a package to be built and that package has the right dependencies available in some releases, but not others, even though the Copr should support all of them. Will she have to submit different &lt;span class="caps"&gt;SRPMS&lt;/span&gt; for each release or should the Copr have the same version of the package in all of its releases? This will be a matter of settling upon a contract that the Copr provides its users and how uniform the Copr&amp;#8217;s content has to be.&lt;/p&gt;
&lt;p&gt;Fedora Summer Coding! Yay!&lt;/p&gt; </description>
            <pubDate>Mon, 09 Aug 2010 12:07 GMT</pubDate>
        </item>
        <item>
            <title>CRUD for Coprs and testing</title>
            <link>http://mapleoin.bluepink.ro/perma/basic-coprs-crud</link>
            <author>mapleoin@bluepink.ro (Oin Maple)</author>
            <description>  &lt;p&gt;This last week I worked on the first controller for the &lt;a href="https://fedoraproject.org/wiki/Category:Copr"&gt;Copr&lt;/a&gt; &lt;a href="https://fedoraproject.org/wiki/Summer_Coding_2010_proposal_-_Copr_TG_app"&gt;TG App&lt;/a&gt;. There is now a &lt;span class="caps"&gt;JSON&lt;/span&gt; &lt;span class="caps"&gt;API&lt;/span&gt; to &lt;span class="caps"&gt;CRUD&lt;/span&gt; Coprs in the TG App&amp;#8217;s database. It also supports adding/removing Copr dependencies. And everything in this first controller is (mostly?) tested with nose unit tests. The happy thing is I&amp;#8217;m still on schedule, though I&amp;#8217;m not ahead of it anymore, which I actually expected.&lt;/p&gt;
&lt;p&gt;I encountered a couple of problems while setting up testing. I installed python-fedora&amp;#8217;s &lt;span class="caps"&gt;FAS&lt;/span&gt; authorization repoze-who plugin and wasted a lot of time trying to get that working with webtest. In the process I managed to screw up something in my TurboGears installation. Since I was already too deep down the rabbit&amp;#8217;s hole I gave up on it. (I also figured out that I don&amp;#8217;t actually need to test anything about the &lt;span class="caps"&gt;FAS&lt;/span&gt; integration so I don&amp;#8217;t even need to install it). So I proceeded to install TG2 inside a python virtualenv which feels a lot more hygienic and will be a lot easier to replace in case of future screw-ups. I had a few problems there aswell since the documented way to install TurboGears2 without distro-packages is broken &lt;span class="caps"&gt;ATM&lt;/span&gt;, but I now have virtualenv! Yay!&lt;/p&gt;
&lt;p&gt;Now the next step is to figure out the right relationship between Coprs and Repos and write some code to manage Repos transparently for the user. I also have to learn to write more frequent status updates.&lt;/p&gt; </description>
            <pubDate>Mon, 02 Aug 2010 18:00 GMT</pubDate>
        </item>
        <item>
            <title>The late Fedora Summer coder</title>
            <link>http://mapleoin.bluepink.ro/perma/the-late-fedora-summer-coder</link>
            <author>mapleoin@bluepink.ro (Oin Maple)</author>
            <description>  &lt;p&gt;I started my &lt;a href="https://fedoraproject.org/wiki/Summer_Coding_2010"&gt;Fedora Summer Coding&lt;/a&gt; last week. Although most people started almost two months ago, I chose (and was allowed to &amp;#8211; Yay, &lt;acronym title="Fedora Summer Coding"&gt;FSC&lt;/acronym&gt;!) a different schedule because I just finished college last week.&lt;/p&gt;
&lt;p&gt;This summer I&amp;#8217;ll be working on a new project for Fedora &amp;#8211; &lt;a href="https://fedoraproject.org/wiki/Category:Copr"&gt;Copr&lt;/a&gt;. Fedora Copr will allow any Fedorian to have their own package repository with packages built and hosted by &lt;a href="https://fedoraproject.org/wiki/Infrastructure"&gt;Fedora&amp;#8217;s Infrastructure&lt;/a&gt;. My mentor this summer will be &lt;a href="http://anonbadger.wordpress.com/"&gt;Toshio&lt;/a&gt;, I&amp;#8217;ve always enjoyed working with him and this summer will be no different. &lt;a href="https://fedoraproject.org/wiki/Summer_Coding_2010_proposal_-_Copr_TG_app"&gt;Here&lt;/a&gt; is my actual &lt;acronym title="Fedora Summer Coding"&gt;FSC&lt;/acronym&gt; proposal. Although the things written in that proposal are turning out to be a bit inaccurate, it&amp;#8217;s still a good bird&amp;#8217;s eye view of what I&amp;#8217;m going to do this summer. &lt;/p&gt;
&lt;p&gt;So about the first week. Things started really slow. I did a lot of orientation, certainly more than I thought I would. I hadn&amp;#8217;t used TurboGears2 before, though I had worked with TurboGears 1.x on &lt;a href="https://admin.fedoraproject.org/pkgdb"&gt;Fedora&amp;#8217;s pkgdb&lt;/a&gt;. When I started out I had only a TG2 automatically generated skeleton app &amp;#8211; well it&amp;#8217;s mostly the same now, though at least I now know a lot more about what&amp;#8217;s in there. The fact that I had to start it up myself meant I had to learn a lot of things about TG2 that I would&amp;#8217;ve normally just copied from other parts of a fully-functional project. And that was a great experience. In a way it&amp;#8217;s fulfilling to be able to &lt;em&gt;pioneer&lt;/em&gt; things in this way ;). I&amp;#8217;m trying to only ask my mentor questions about designing the actual app and solve my &amp;#8220;How do I &amp;#8230; in TurboGears/Python?&amp;#8221; questions elsewhere. My mentor has always given me a lot of independence when working on things and that feels really good, though at times I feel inexperienced. There&amp;#8217;s the thought that the project I&amp;#8217;m working on will be used by a lot of technical users and I&amp;#8217;m really not sure what my decisions&amp;#8217; impact will be on the whole project.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m mostly on time with my &lt;a href="https://fedoraproject.org/wiki/Summer_Coding_2010_proposal_-_Copr_TG_app#Timeline"&gt;mock-up schedule&lt;/a&gt; because I had set the first week for orienteering. I also wrote the DB schema for Coprs, though that was on the second week. That doesn&amp;#8217;t mean I&amp;#8217;m ahead of schedule however, because I&amp;#8217;ll probably have a lot to work on the Copr controllers, and a lot of documenting and designing.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m proud that I setup testing after a day of wading through the scattered documentation of TurboGears2 testing. There&amp;#8217;s mostly no documentation on testing on the &lt;a href="http://www.turbogears.org/2.0/docs/toc.html"&gt;TurboGears2.0 docs website&lt;/a&gt;. So I went to the &lt;a href="http://somethingaboutorange.com/mrl/projects/nose/0.11.2/"&gt;python nose&lt;/a&gt; webpage. But they don&amp;#8217;t have any info on the TurboGears2 web helpers which I needed to use. So I went to &lt;a href="http://pylonsbook.com/en/1.1/testing.html"&gt;pylonshq docs about testing&lt;/a&gt;, but they use a slightly different syntax because they&amp;#8217;re using paste.fixture. I finally found the &lt;a href="http://turbogears.org/2.1/docs/main/Testing/index.html"&gt;TurboGears2.1 testing docs&lt;/a&gt; which was what I really needed. It turns out that TurboGears 2.x uses &lt;a href="http://pythonpaste.org/webtest/"&gt;WebTest&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So now I have testing. My project is not supposed to have any web interface at this point, so writing tests is the easiest way to prove that things are actually working.&lt;/p&gt;
&lt;p&gt;This next week I&amp;#8217;ll probably get some work done on Copr controllers. Implementing the ability to &lt;span class="caps"&gt;CRUD&lt;/span&gt; Coprs and Repos.&lt;/p&gt; </description>
            <pubDate>Sun, 25 Jul 2010 14:00 GMT</pubDate>
        </item>
        <item>
            <title>Cum să actualizezi metadatele yum în mod automat</title>
            <link>http://mapleoin.bluepink.ro/perma/actualizare-automata-metadata-yum</link>
            <author>mapleoin@bluepink.ro (Oin Maple)</author>
            <description>  &lt;p&gt;Unul dintre lucrurile care mă enervează cel mai tare ca utilizator desktop la yum e că de fiecare dată când vreau să caut sau să instalez un pachet, trebuie să aștept câteva secunde bune până își actualizează metadatele pentru toate depozitele active. Astăzi am avut timp să caut o metodă de a scăpa de neplăcerea asta și a fost destul de simplu de găsit.&lt;/p&gt;
&lt;p&gt;Rezolvarea nu este să dezactivăm complet actualizarea metadatelor, pentru că am putea încerca să instalăm pachete a căror dependințe au fost actualizate și a căror versiune exactă nu se mai găsește în depozit =&gt; &lt;em&gt;dependency hell&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Se pare că există un program &lt;em&gt;yum-updatesd&lt;/em&gt; (&lt;code&gt;su -c &amp;#34;yum install yum-updatesd&amp;#34;&lt;/code&gt;) care poate actualiza automat metadatele.&lt;/p&gt;
&lt;p&gt;După ce l-am instalat, putem modifica &lt;code&gt;/etc/yum/yum-updatesd.conf&lt;/code&gt; dacă vrem să facem lucruri dubioase, cum ar fi să îl lăsăm să instaleze actualizări automat &amp;#8212; pentru că trăim într-o utopie în care actualizările nu strică niciodată nimic &amp;#8212; sau, mai puțin dubios, doar să le descarce.&lt;/p&gt;
&lt;p&gt;Acum că am terminat cu setările, putem porni serviciul cu:&lt;/p&gt;
&lt;div class="Bash"&gt;&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="nv"&gt;$ &lt;/span&gt;su -c &lt;span class="s2"&gt;&amp;quot;service yum-updatesd start&amp;quot;&lt;/span&gt;
 &lt;span class="nv"&gt;$ &lt;/span&gt;cacamaca
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Și îl putem pune să se pornească automat la fiecare boot:&lt;/p&gt;
&lt;div class="Bash"&gt;&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="nv"&gt;$ &lt;/span&gt;su -c &lt;span class="s2"&gt;&amp;quot;chkconfig yum-updatesd on&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt; </description>
            <pubDate>Thu, 18 Mar 2010 14:00 GMT</pubDate>
        </item>
        <item>
            <title>Cum să peticești un rpm (patch rpm)</title>
            <link>http://mapleoin.bluepink.ro/perma/cum-sa-peticesti-un-rpm</link>
            <author>mapleoin@bluepink.ro (Oin Maple)</author>
            <description>  &lt;p&gt;O să vă descriu cum am aplicat un petec pentru unul dintre pachetele pentru care sunt responsabil la fedora: calibre, în timp ce așteptam să-mi vină pizza http://www.fedoraproject.ro/am-lansat-fedora-12-avans . Petecul este răspunsul la un bug report: https://bugzilla.redhat.com/show_bug.cgi?id=537525 . Calibre verifică de fiecare dată când este pornit dacă pe situl oficial a apărut o nouă versiune și dacă a apărut, îl anunță pe utilizator printr-un pop-up că trebuie să actualizeze aplicația. Cum fedora are propriul management al pachetelor și deci și al actualizărilor, este recomandat ca pachetele noi să fie instalate folosind yum; deci mesajul trebuie eliminat.&lt;/p&gt;
&lt;p&gt;Mai întâi trebuie să descărcăm sursele actuale ale rpm-ului (în momentul în care am scris patchul, în repo-uri cea mai recentă versiune era 0.6.21-1, acum ar trebui să fie una cu patchul deja aplicat):&lt;/p&gt;
&lt;pre&gt;
  $ yumdownloader --source calibre
&lt;/pre&gt;
&lt;p&gt;și să le despachetăm:&lt;/p&gt;
&lt;div class="Bash"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="nv"&gt;$ &lt;/span&gt;rpm -ivh calibre-0.6.21-1.fc12.src.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Comanda va crea un nou director rpmbuild, cu subdirectoarele &lt;span class="caps"&gt;SPECS&lt;/span&gt; și &lt;span class="caps"&gt;SOURCES&lt;/span&gt;. În &lt;span class="caps"&gt;SPECS&lt;/span&gt; avem fișierul care ține toate informațiile despre cum se va construi pachetul: calibre.spec, iar în &lt;span class="caps"&gt;SOURCES&lt;/span&gt; avem sursele pachetului și toate patchurile pe care le-am creat până acum:&lt;/p&gt;
&lt;pre&gt;
  $ tree rpmbuild/
  rpmbuild/
  |-- SOURCES
  |   |-- calibre-0.6.21-nofonts.tar.gz
  |   |-- calibre-cssprofiles.patch
  |   |-- calibre-manpages.patch
  |   `-- generate-tarball.sh
  `-- SPECS
  `-- calibre.spec
&lt;/pre&gt;
&lt;p&gt;Mai avem de făcut un pas, ca să putem umbla prin sursele programului. Trebuie să dezarhivăm arhiva calibre-0.6.21-nofonts.tar.gz. Următoarea comandă dezarhivează și aplică patchurile pe care le avem deja:&lt;/p&gt;
&lt;pre&gt;
  $ cd rpmbuild/SPECS
  $ rpmbuild -bp calibre.spec
&lt;/pre&gt;
&lt;p&gt;Au apărut mai multe directoare după comanda asta:&lt;/p&gt;
&lt;pre&gt;
  $ ls rpmbuild/
  BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS
&lt;/pre&gt;
&lt;p&gt;Cel care ne interesează este &lt;span class="caps"&gt;BUILD&lt;/span&gt;, în care au apărut sursele peticite ale programului.&lt;/p&gt;
&lt;p&gt;Atunci când e pornit, dacă există o versiune mai nouă, calibre va afișa următorul mesaj în fereastra pop-up:&lt;/p&gt;
&lt;p&gt;calibre has been updated to version 0.6.24. See the new features. Visit the download page?&lt;/p&gt;
&lt;p&gt;Ca să aflăm din ce fișier vine fereastra de pop-up putem să căutăm pur și simplu o parte din textul de mai sus în sursele calibre:&lt;/p&gt;
&lt;pre&gt;
  $ cd rpmbuild/BUILD/calibre/
  $ find .|xargs grep &amp;#34;has been updated&amp;#34;
&lt;/pre&gt;
&lt;p&gt;Dacă ignorăm fișierele de localizare, vom afla sursa pop-up-ului:&lt;/p&gt;
&lt;pre&gt;
  ./calibre/src/calibre/gui2/main.py:                    _(&amp;#39;%s has been updated to version %s. &amp;#39;
&lt;/pre&gt;
&lt;p&gt;Mergând în fișierul respectiv vedem că acel cod face parte dintr-o funcție numită update_found:&lt;/p&gt;
&lt;div class="Bash"&gt;&lt;div class="highlight"&gt;&lt;pre&gt; 
  def update_found&lt;span class="o"&gt;(&lt;/span&gt;self, version&lt;span class="o"&gt;)&lt;/span&gt;:
  &lt;span class="nv"&gt;os&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;windows&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;if &lt;/span&gt;iswindows &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;osx&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;if &lt;/span&gt;isosx &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;linux&amp;#39;&lt;/span&gt;
  &lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://%s.kovidgoyal.net/download_%s&amp;#39;&lt;/span&gt;%&lt;span class="o"&gt;(&lt;/span&gt;__appname__, os&lt;span class="o"&gt;)&lt;/span&gt;
  self.latest_version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ne interesează ca modificarea pe care o vom aduce să fie cât mai lizibilă pentru cei care vor modifica pachetul nostru mai târziu și să fie cât mai ușor de revenit la versiunea nemodificată. Dacă ne uităm mai atent în main, găsim următorul cod:&lt;/p&gt;
&lt;div class="Python"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_update_check&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update_checker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CheckForUpdates&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;QObject&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update_checker&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;update_found(PyQt_PyObject)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update_found&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update_checker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Codul verifică dacă programul a fost pornit cu opțiunea no_update_check. Ar complica prea mult lucrurile dacă am modifica programul în așa fel încât să pornească de fiecare dată cu opțiunea asta așa că mai bine comentăm codul aici, ca să nu mai verifice opțiunea și deci să nu mai caute niciodată update-uri. E soluția cea mai simplă.&lt;/p&gt;
&lt;p&gt;Ca să facem un petec ca la carte, vom face așa:&lt;/p&gt;
&lt;p&gt;Facem o copie a fișierului main.py:&lt;/p&gt;
&lt;pre&gt;
  $ cd ~/rpmbuild/BUILD/calibre/src/calibre/gui2/
  $ cp main.py main.py.no_update
  După care modificăm *fișierul inițial* și comentăm codul respectiv așa:
  # if not opts.no_update_check:
  #     self.update_checker = CheckForUpdates()
  #     QObject.connect(self.update_checker,
  #             SIGNAL(&amp;#39;update_found(PyQt_PyObject)&amp;#39;), self.update_found)
  #     self.update_checker.start()
&lt;/pre&gt;
&lt;p&gt;Ca să generăm petecul vom folosi gendiff din directorul de deasupra directorului rădăcină:&lt;/p&gt;
&lt;div class="Diff"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;    $ cd ~/rpmbuild/BUILD
    $ gendiff calibre .no_update
    diff -up calibre/src/calibre/gui2/main.py.no_update calibre/src/calibre/gui2/main.py
    --- calibre/src/calibre/gui2/main.py.no_update	2009-11-16 14:21:55.200387171 +0200
    +++ calibre/src/calibre/gui2/main.py	2009-11-16 14:22:10.400510757 +0200
    @@ -221,11 +221,11 @@ class Main(MainWindow, Ui_MainWindow, De
    self.latest_version = &amp;#39; &amp;#39;
    self.vanity.setText(self.vanity_template%dict(version=&amp;#39; &amp;#39;, device=&amp;#39; &amp;#39;))
    self.device_info = &amp;#39; &amp;#39;
    -        if not opts.no_update_check:
    -            self.update_checker = CheckForUpdates()
    -            QObject.connect(self.update_checker,
    -                    SIGNAL(&amp;#39;update_found(PyQt_PyObject)&amp;#39;), self.update_found)
    -            self.update_checker.start()
    +        # if not opts.no_update_check:
    +        #     self.update_checker = CheckForUpdates()
    +        #     QObject.connect(self.update_checker,
    +        #             SIGNAL(&amp;#39;update_found(PyQt_PyObject)&amp;#39;), self.update_found)
    +        #     self.update_checker.start()
    ####################### Status Bar #####################
    self.status_bar = StatusBar(self.jobs_dialog, self.system_tray_icon)
    self.setStatusBar(self.status_bar)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Totul arată bine, deci putem să-l punem în surse:&lt;/p&gt;
&lt;pre&gt;
  $ gendiff calibre .no_update &amp;#62; ~/rpmbuild/SOURCES/calibre-no-update.patch
&lt;/pre&gt;
&lt;p&gt;Acum trebuie să modificăm spec-ul, adăugând un nou petec, incrementând release-ul, menționând motivul pentru petec și scriind modificarea în Changelog:&lt;/p&gt;
&lt;div class="Diff"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  @@ -1,6 +1,6 @@
  Name:           calibre
  Version:        0.6.21
  -Release:        1%{?dist}
  +Release:        2%{?dist}
  Summary:        E-book converter and library management
  Group:          Applications/Multimedia
  License:        GPLv3
  @@ -18,6 +18,7 @@
  Source1:        generate-tarball.sh
  Patch0:         %{name}-cssprofiles.patch
  Patch1:         %{name}-manpages.patch
  +Patch2:         %{name}-no-update.patch
  BuildRoot:      %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
  BuildRequires:  python &amp;gt;= 2.6
  @@ -72,6 +73,9 @@
  # don&amp;#39;t append calibre1 to the name of the manpages. No need to compress either
  %patch1 -p1 -b .manpages
  +# don&amp;#39;t check for new upstream version (that&amp;#39;s what packagers do)
  +%patch2 -p1 -b .no-update
  +
  # dos2unix newline conversion
  %{__sed} -i &amp;#39;s/\r//&amp;#39; src/calibre/web/feeds/recipes/*
  @@ -239,6 +243,9 @@
  %{_mandir}/man1/*
  %changelog
  +* Sat Nov  29 2009 Ionuț C. Arțăriși 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Gata. Asta a fost tot :). Acum putem reconstrui pachetul cu noile patchuri:&lt;/p&gt;
&lt;pre&gt;
  $ cd ~/rpmbuild/SPECS/
  $ rpmbuild -ba calibre.spec
&lt;/pre&gt;
&lt;p&gt;Și putem reinstala noul pachet:&lt;/p&gt;
&lt;pre&gt;
  $ su -c &amp;#34;yum localinstall -y --nogpgcheck ~/rpmbuild/RPMS/x86_64/calibre-0.6.21-2.fc12.x86_64.rpm&amp;#34;
&lt;/pre&gt; </description>
            <pubDate>Mon, 30 Nov 2009 12:00 GMT</pubDate>
        </item>
        <item>
            <title>The Productive Programmer</title>
            <link>http://mapleoin.bluepink.ro/perma/productive-programmer-review</link>
            <author>mapleoin@bluepink.ro (Oin Maple)</author>
            <description>  &lt;p&gt;Today I read &lt;a href="http://www.amazon.com/gp/product/0596519788?ie=UTF8&amp;amp;tag=httpmapleoinb-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0596519788"&gt;The Productive Programmer&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ve already got a bunch of books piled up and waiting to be read, some of which I&amp;#8217;ve reached the middle of and some of which I&amp;#8217;ve read only the introduction to. I was bored today and this looked like an easy read that I could drop at any time. It is an easy read, but the fact is, it&amp;#8217;s very catchy. It draws you in and doesn&amp;#8217;t want to be let go. It&amp;#8217;s a great way to spend half a day.&lt;/p&gt;
&lt;p&gt;This could have been another one of those &amp;#8220;94 things you need to know&amp;#8221; books, but I think this title is way better. The tips are divided into 2 big sections and a few separate chapters within each one, giving the book some structure. One of the strange things about it is that its advice spans across 3 different platforms (*nix, OS X and Windows) and they&amp;#8217;re all mingled together in the same chapter. I was put off by this at first, but after I&amp;#8217;d gotten into the book a bit I realized that it is, in fact, a good idea. The whole theme of the book is programmer productivity and the reason it has this title and not a cheesy title with numbers like &amp;#8220;94.3 productivity tips for programmers&amp;#8221; is that the tips aren&amp;#8217;t what&amp;#8217;s important. The book is there to hit people in the head with and open their minds. You aren&amp;#8217;t supposed to just use the tips provided, that&amp;#8217;s unimportant. What&amp;#8217;s important is that you have a shock and realize that you&amp;#8217;ve been the wrong kind of lazy as a programmer. You&amp;#8217;ve stopped automating, you&amp;#8217;ve become a machine; in the author&amp;#8217;s own words, computers have started &amp;#8220;getting together late at night to make fun of their users&amp;#8221;. As soon as I realized what this book was really about, I started reading the Windows tips as well. I also stopped a few times to look in my distro&amp;#8217;s repository for tools that I had known of, but never used before, only now understanding their true purpose. There are many applications that seem just trendy at first, until you realize that even a small productivity boost is a big productivity boost. (Go check out &lt;i&gt;gnome-do&lt;/i&gt; , I&amp;#8217;d heard about it years ago, but never tried it until now).&lt;br /&gt;The book contains tips ranging from application launchers, Firefox&amp;#8217;s magic address bar, bash scripting commands to office productivity tips for killing distractions. Once again, the mindset is important, not the tips themselves. The big take-away from this book is beginning to constantly judge everything you do as a programmer. This isn&amp;#8217;t new advice (at least for those who have read &lt;a href="http://www.amazon.com/gp/product/020161622X?ie=UTF8&amp;amp;tag=httpmapleoinb-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=020161622X"&gt;The Pragmatic Programmer&lt;/a&gt;&amp;#8221;, which by the way is mentioned several times in this book), but I find it&amp;#8217;s better emphasized in this book. At one point in the book, the author explains how it took his team one hour to devise a Ruby script to automate some simple task that would&amp;#8217;ve required 10 minutes if done manually and finally only needed doing 5 times. One could say there was a loss in productivity, but as the author points out, one would be wrong. Those 50 minutes would&amp;#8217;ve been spent with the brain turned off, whereas the hour writing the script was spent &lt;i&gt;learning&lt;/i&gt;, focusing, practicing, gaining knowledge that can later be used on a different project. Some of us would probably have gotten bored in those 50 minutes and fallen into procrastination. That doesn&amp;#8217;t happen when you&amp;#8217;ve got a complex problem to solve.&lt;br /&gt;That was the first part of the book, &lt;i&gt;Mechanics&lt;/i&gt;. The second part, &lt;i&gt;Practice&lt;/i&gt; is a bit harder to read, as it&amp;#8217;s not just disparaged tips on very different applications. They&amp;#8217;re quite two separate books actually. The majority of the examples in Part IIare java (they&amp;#8217;re mostly readable even for someone who doesn&amp;#8217;t speak the exact dialect of &lt;span class="caps"&gt;OOP&lt;/span&gt; that java uses) and this part is mostly about software &lt;i&gt;construction&lt;/i&gt; as &lt;a href="http://www.amazon.com/gp/product/0735619670?ie=UTF8&amp;amp;tag=httpmapleoinb-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0735619670"&gt;Steve McConnell&lt;/a&gt; would say, but it&amp;#8217;s also about Java. I learned a new acronym: &lt;acronym title="You Ain’t Gonna Need It"&gt;YAGNI&lt;/acronym&gt; which basically means that thinking ahead is bad. This is probably one of the advices that I feel the least guilty about, but which I sometime observe in people around me. Never program a feature you don&amp;#8217;t urgently have a need for.&lt;br /&gt;One of the good points of this book is the originality with which the ideas are expressed. Most of these ideas aren&amp;#8217;t new, especially to anyone who&amp;#8217;s read other software engineering books. The text is spiced up with little narratives of different adventures from the author&amp;#8217;s experience as a consultant and there is also an &lt;i&gt;Ancient Philosophers&lt;/i&gt; chapter and an explanation of the PacMan game&amp;#8217;s way of functioning (although I didn&amp;#8217;t understand how that&amp;#8217;s supposed to make the game less enjoyable).&lt;/p&gt; </description>
            <pubDate>Fri, 18 Sep 2009 14:00 GMT</pubDate>
        </item>
    </channel>
</rss>
